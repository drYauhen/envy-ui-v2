<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Envy UI Tokens Adapter</title>
    <style>
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: #0f172a;
        color: #f8fafc;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 16px;
      }

      h1 {
        font-size: 16px;
        margin: 0;
      }

      .tabs {
        display: inline-flex;
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        overflow: hidden;
      }

      .tab {
        background: transparent;
        color: #cbd5f5;
        padding: 10px 14px;
        border: none;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        transition: background 120ms ease, color 120ms ease;
      }

      .tab.active {
        background: rgba(255, 255, 255, 0.1);
        color: #f8fafc;
      }

      .panel {
        display: none;
        flex-direction: column;
        gap: 12px;
      }

      .panel.active {
        display: flex;
      }

      textarea {
        width: 100%;
        min-height: 180px;
        border-radius: 8px;
        border: none;
        padding: 12px;
        font-family: 'JetBrains Mono', Consolas, monospace;
        font-size: 12px;
        resize: vertical;
      }

      button,
      label {
        font-size: 13px;
        font-weight: 600;
        border-radius: 6px;
        cursor: pointer;
      }

      button {
        border: none;
        background: #10b981;
        color: #041421;
        padding: 10px 16px;
        transition: opacity 120ms ease;
        cursor: pointer;
      }

      button.secondary {
        background: transparent;
        color: #cbd5f5;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      button:not(:disabled):hover {
        filter: brightness(1.06);
      }

      button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .actions {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .actions-row {
        display: flex;
        gap: 8px;
        width: 100%;
      }

      .actions-row button {
        flex: 1;
      }

      .actions-row button.full-width {
        width: 100%;
      }

      .status {
        font-size: 12px;
        color: #cbd5f5;
        min-height: 18px;
      }

      input[type='file'] {
        display: none;
      }

      .reload-strip {
        font-size: 11px;
        color: #94a3b8;
        padding: 4px 8px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        align-self: flex-start;
      }
    </style>
  </head>
  <body>
    <div class="tabs">
      <button class="tab active" data-tab="variables">Variables</button>
      <button class="tab" data-tab="structures">Structures</button>
      <button class="tab" data-tab="applicator">Applicator</button>
      <button class="tab" data-tab="snapshot">Snapshot</button>
      <button class="tab" data-tab="migration">Migration</button>
    </div>
    <div id="reloadTimestamp" class="reload-strip"></div>

    <div id="variablesPanel" class="panel active">
      <h1>Import variables JSON</h1>
      <p style="margin: 0; font-size: 12px; color: #cbd5f5;">
        Paste the contents of <code>generated/figma/tokens/variables.tokens.scoped.json</code> (new format with modes) or <code>generated/figma/adapter/variables.adapter.json</code> (old format) or load it from disk.
      </p>
      <textarea id="adapterInput" placeholder="{\n  \"collections\": []\n}"></textarea>
      <div class="actions">
        <div class="actions-row">
          <button id="loadJsonButton" class="secondary full-width">
            Load JSON file
          </button>
          <input type="file" id="fileInput" accept="application/json" style="display: none;" />
        </div>
        <div class="actions-row">
          <button id="importButton" disabled>Prepare import</button>
          <button id="confirmButton" class="secondary" disabled>Apply changes</button>
        </div>
        <div id="defaultModeSelector" style="display: none; flex-direction: column; gap: 8px;">
          <label style="display: flex; flex-direction: column; gap: 4px; font-size: 12px; color: #cbd5f5;">
            <span>Default mode (will be mode 0 in Figma):</span>
            <select id="defaultModeSelect" style="padding: 8px; border-radius: 6px; border: 1px solid rgba(255, 255, 255, 0.2); background: rgba(255, 255, 255, 0.05); color: #f8fafc; font-size: 13px;">
              <option value="">Select default mode...</option>
            </select>
          </label>
        </div>
      </div>
      <div class="status" id="status"></div>
    </div>

    <div id="structuresPanel" class="panel">
      <h1>Component / Structure Generator</h1>
      <p style="margin: 0; font-size: 12px; color: #cbd5f5;">Generate eui.button structure from tokens.</p>
      <label class="secondary">
        <input type="file" id="structuresFile" accept="application/json" />
        Load structures JSON
      </label>
      <button id="generateStructures">Generate eui.button</button>
      <div class="status" id="structuresStatus"></div>
    </div>

    <div id="applicatorPanel" class="panel">
      <h1>Applicator</h1>
      <p style="margin: 0; font-size: 12px; color: #cbd5f5;">Map layers to semantic roles. No changes applied.</p>
      <button id="refreshSelection">Refresh selection</button>
      <div class="status" id="applicatorStatus" style="min-height: 18px;"></div>

      <div id="selectionDetails" style="display: none; font-size: 12px; color: #cbd5f5; gap: 4px; flex-direction: column;">
        <div><strong>Selection:</strong> <span id="selType"></span></div>
        <div><strong>Name:</strong> <span id="selName"></span></div>
        <div><strong>ID:</strong> <span id="selId"></span></div>
        <div><strong>Children:</strong> <span id="selChildCount"></span></div>
      </div>

      <div id="layersList" style="display: none;">
        <h2 style="font-size: 13px; margin: 12px 0 4px;">Layers</h2>
        <div id="layersTable" style="display: flex; flex-direction: column; gap: 4px;"></div>
      </div>

      <div id="roleMapping" style="display: none;">
        <h2 style="font-size: 13px; margin: 12px 0 4px;">Semantic roles</h2>
        <div style="display: flex; flex-direction: column; gap: 8px;">
          <label style="display: flex; flex-direction: column; gap: 4px;">
            <span>Background (Rectangle)</span>
            <select id="roleBackground"></select>
          </label>
          <label style="display: flex; flex-direction: column; gap: 4px;">
            <span>Label (Text)</span>
            <select id="roleLabel"></select>
          </label>
          <label style="display: flex; flex-direction: column; gap: 4px;">
            <span>Border (optional)</span>
            <select id="roleBorder"></select>
          </label>
          <label style="display: flex; flex-direction: column; gap: 4px;">
            <span>Icon (optional)</span>
            <select id="roleIcon"></select>
          </label>
        </div>
      </div>

      <div style="margin-top: 12px; display: flex; gap: 8px; flex-wrap: wrap;">
        <button id="saveMapping" disabled>Save Mapping</button>
        <button id="applyTokens" disabled>Apply Tokens</button>
        <button id="expandVariants" disabled>Expand Variants</button>
      </div>
      <p style="margin: 4px 0 0; font-size: 12px; color: #cbd5f5;">
        Coming next: batch-apply variables + expand variants from a seed component.
      </p>
      <h2 style="font-size: 13px; margin: 12px 0 4px;">Detected Variable Axes</h2>
      <div id="axesList" style="display: flex; flex-direction: column; gap: 6px; font-size: 12px; color: #cbd5f5;"></div>
      <div id="axesStatusLine" style="font-size: 11px; color: #94a3b8; min-height: 14px;">Axes detected: 0 | Selected axis: — | Bindings used: 0</div>
    </div>

    <div id="snapshotPanel" class="panel">
      <h1>Export Snapshot</h1>
      <p style="margin: 0; font-size: 12px; color: #cbd5f5;">
        Export current Figma Variables state for migration tracking. 
        Use this before changing token structure to create a baseline for migration.
      </p>
      
      <div id="snapshotSummary" style="display: none; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 6px; margin: 12px 0;">
        <div style="font-size: 12px; color: #cbd5f5; display: flex; flex-direction: column; gap: 4px;">
          <div>Collections: <strong id="snapshotCollectionsCount">0</strong></div>
          <div>Variables: <strong id="snapshotVariablesCount">0</strong></div>
          <div>Total usages: <strong id="snapshotUsagesCount">0</strong></div>
          <div>Variables with bindings: <strong id="snapshotVariablesWithUsagesCount">0</strong></div>
        </div>
      </div>
      
      <button id="exportSnapshotBtn">Create Snapshot</button>
      
      <div id="snapshotResult" style="display: none; margin-top: 12px;">
        <label style="display: flex; flex-direction: column; gap: 4px; font-size: 12px; color: #cbd5f5;">
          <span>Snapshot JSON:</span>
          <textarea id="snapshotJson" readonly style="min-height: 200px; font-family: 'JetBrains Mono', Consolas, monospace; font-size: 11px;"></textarea>
        </label>
        <div class="actions-row" style="margin-top: 8px;">
          <button id="copySnapshotBtn" class="secondary">Copy to Clipboard</button>
          <button id="downloadSnapshotBtn" class="secondary">Download JSON</button>
        </div>
      </div>
      
      <div class="status" id="snapshotStatus"></div>
      
      <hr style="border: none; border-top: 1px solid rgba(255, 255, 255, 0.1); margin: 24px 0;" />
      
      <h1 style="margin-top: 0;">Restore from Snapshot</h1>
      <p style="margin: 0; font-size: 12px; color: #cbd5f5;">
        Restore Figma Variables from a snapshot backup. 
        Load snapshot file to see what will be restored before applying changes.
      </p>
      
      <textarea id="restoreSnapshotInput" placeholder="{\n  \"timestamp\": \"...\",\n  \"collections\": [],\n  \"variables\": []\n}" style="min-height: 120px;"></textarea>
      
      <div class="actions">
        <div class="actions-row">
          <button id="loadSnapshotButton" class="secondary full-width">
            Load Snapshot file
          </button>
          <input type="file" id="restoreFileInput" accept="application/json" style="display: none;" />
        </div>
        <div class="actions-row">
          <button id="prepareRestoreButton" disabled>Prepare restore</button>
          <button id="executeRestoreButton" class="secondary" disabled>Restore from Snapshot</button>
        </div>
      </div>
      
      <div class="status" id="restoreStatus"></div>
    </div>

    <div id="migrationPanel" class="panel">
      <h1>Apply Migration</h1>
      <p style="margin: 0; font-size: 12px; color: #cbd5f5;">
        Apply migration file to update Figma Variable bindings when token structure changes.
        Load migration file to see what will be changed before applying.
      </p>
      
      <textarea id="migrationInput" placeholder="{\n  \"version\": \"2025-12-31\",\n  \"deleted\": [],\n  \"moved\": []\n}" style="min-height: 120px;"></textarea>
      
      <div class="actions">
        <div class="actions-row">
          <button id="loadMigrationButton" class="secondary full-width">
            Load Migration file
          </button>
          <input type="file" id="migrationFileInput" accept="application/json" style="display: none;" />
        </div>
        <div class="actions-row">
          <button id="prepareMigrationButton" disabled>Prepare migration</button>
          <button id="executeMigrationButton" class="secondary" disabled>Apply Migration</button>
        </div>
      </div>
      
      <div id="migrationSummary" style="display: none; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 6px; margin: 12px 0;">
        <div style="font-size: 12px; color: #cbd5f5; display: flex; flex-direction: column; gap: 4px;">
          <div>Total changes: <strong id="migrationTotalChanges">0</strong></div>
          <div>Deleted variables: <strong id="migrationDeletedCount">0</strong></div>
          <div>Moved variables: <strong id="migrationMovedCount">0</strong></div>
          <div>Usages affected: <strong id="migrationUsagesAffected">0</strong></div>
          <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
            <div style="color: #fbbf24; font-weight: 600;">⚠️ Variables requiring review: <strong id="migrationRequiresReview">0</strong></div>
          </div>
        </div>
      </div>
      
      <div class="status" id="migrationStatus"></div>
    </div>

    <script>
      const tabs = Array.from(document.querySelectorAll('.tab'));
      const variablesPanel = document.getElementById('variablesPanel');
      const structuresPanel = document.getElementById('structuresPanel');
      const applicatorPanel = document.getElementById('applicatorPanel');
      const snapshotPanel = document.getElementById('snapshotPanel');
      const migrationPanel = document.getElementById('migrationPanel');

      tabs.forEach((tab) => {
        tab.addEventListener('click', () => {
          const target = tab.getAttribute('data-tab');
          tabs.forEach((t) => t.classList.toggle('active', t === tab));
          variablesPanel.classList.toggle('active', target === 'variables');
          structuresPanel.classList.toggle('active', target === 'structures');
          applicatorPanel.classList.toggle('active', target === 'applicator');
          snapshotPanel.classList.toggle('active', target === 'snapshot');
          migrationPanel.classList.toggle('active', target === 'migration');
        });
      });

      const input = document.getElementById('adapterInput');
      const fileInput = document.getElementById('fileInput');
      const loadJsonButton = document.getElementById('loadJsonButton');
      const importButton = document.getElementById('importButton');
      const confirmButton = document.getElementById('confirmButton');
      const status = document.getElementById('status');
      const structuresStatus = document.getElementById('structuresStatus');
      const generateStructures = document.getElementById('generateStructures');
      const structuresFile = document.getElementById('structuresFile');
      const refreshSelection = document.getElementById('refreshSelection');
      const applicatorStatus = document.getElementById('applicatorStatus');
      const selectionDetails = document.getElementById('selectionDetails');
      const layersList = document.getElementById('layersList');
      const layersTable = document.getElementById('layersTable');
      const roleMapping = document.getElementById('roleMapping');
      const selType = document.getElementById('selType');
      const selName = document.getElementById('selName');
      const selId = document.getElementById('selId');
      const selChildCount = document.getElementById('selChildCount');
      const roleBackground = document.getElementById('roleBackground');
      const roleLabel = document.getElementById('roleLabel');
      const roleBorder = document.getElementById('roleBorder');
      const roleIcon = document.getElementById('roleIcon');
      const axesList = document.getElementById('axesList');
      const expandVariantsBtn = document.getElementById('expandVariants');
      const saveMappingBtn = document.getElementById('saveMapping');
      const applyTokensBtn = document.getElementById('applyTokens');
      let lastPayload = null;
      let structuresPayload = null;
      let latestSelection = null;
      let selectedAxis = null;
      let selectedAxisId = null;
      let hasAxesCached = false;
      let axesBindingsCount = 0;

      // Snapshot panel elements
      const exportSnapshotBtn = document.getElementById('exportSnapshotBtn');
      const snapshotResult = document.getElementById('snapshotResult');
      const snapshotJson = document.getElementById('snapshotJson');
      const copySnapshotBtn = document.getElementById('copySnapshotBtn');
      const downloadSnapshotBtn = document.getElementById('downloadSnapshotBtn');
      const snapshotStatus = document.getElementById('snapshotStatus');
      const snapshotSummary = document.getElementById('snapshotSummary');
      const snapshotCollectionsCount = document.getElementById('snapshotCollectionsCount');
      const snapshotVariablesCount = document.getElementById('snapshotVariablesCount');
      const snapshotUsagesCount = document.getElementById('snapshotUsagesCount');
      const snapshotVariablesWithUsagesCount = document.getElementById('snapshotVariablesWithUsagesCount');

      // Restore snapshot elements
      const restoreSnapshotInput = document.getElementById('restoreSnapshotInput');
      const restoreFileInput = document.getElementById('restoreFileInput');
      const loadSnapshotButton = document.getElementById('loadSnapshotButton');
      const prepareRestoreButton = document.getElementById('prepareRestoreButton');
      const executeRestoreButton = document.getElementById('executeRestoreButton');
      const restoreStatus = document.getElementById('restoreStatus');
      let lastRestoreSnapshot = null;

      // Request timestamp in case the message arrives before UI initialization.
      parent.postMessage({ pluginMessage: { type: 'request-timestamp' } }, '*');

      // Function to check if input has content and enable/disable Prepare import button
      function updateImportButtonState() {
        const hasContent = input.value.trim().length > 0;
        importButton.disabled = !hasContent;
      }

      // Load JSON button click handler
      loadJsonButton.addEventListener('click', () => {
        fileInput.click();
      });

      fileInput.addEventListener('change', (event) => {
        const file = event.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          input.value = reader.result;
          status.textContent = `Loaded ${file.name}`;
          confirmButton.disabled = true;
          lastPayload = null;
          updateImportButtonState();
        };
        reader.readAsText(file);
      });

      input.addEventListener('input', () => {
        confirmButton.disabled = true;
        lastPayload = null;
        updateImportButtonState();
      });

      // Initialize button state
      updateImportButtonState();

      importButton.addEventListener('click', () => {
        try {
          const payload = JSON.parse(input.value);
          lastPayload = payload;
          confirmButton.disabled = true;
          status.textContent = 'Preparing summary...';
          
          // Извлечь все уникальные моды из всех коллекций
          const allModes = new Set();
          if (payload.collections) {
            payload.collections.forEach(collection => {
              if (collection.modes && Array.isArray(collection.modes)) {
                collection.modes.forEach(mode => allModes.add(mode));
              }
            });
          }
          
          console.log('[UI] Found modes:', Array.from(allModes));
          
          // Показать дропдаун и заполнить опциями
          const defaultModeSelector = document.getElementById('defaultModeSelector');
          const defaultModeSelect = document.getElementById('defaultModeSelect');
          
          console.log('[UI] defaultModeSelector:', defaultModeSelector);
          console.log('[UI] defaultModeSelect:', defaultModeSelect);
          
          if (allModes.size > 0 && defaultModeSelector && defaultModeSelect) {
            // Очистить старые опции (кроме первой пустой)
            defaultModeSelect.innerHTML = '<option value="">Select default mode...</option>';
            
            // Добавить опции для каждого мода
            Array.from(allModes).sort().forEach(mode => {
              const option = document.createElement('option');
              option.value = mode;
              option.textContent = mode;
              // По умолчанию выбрать app-default, если он есть
              if (mode === 'app-default') {
                option.selected = true;
              }
              defaultModeSelect.appendChild(option);
            });
            
            defaultModeSelector.style.display = 'flex';
            console.log('[UI] Showing default mode selector with', allModes.size, 'modes');
          } else {
            console.warn('[UI] Cannot show default mode selector:', {
              modesCount: allModes.size,
              selectorExists: !!defaultModeSelector,
              selectExists: !!defaultModeSelect
            });
            if (defaultModeSelector) defaultModeSelector.style.display = 'none';
          }
          
          parent.postMessage({ pluginMessage: { type: 'prepare-import', payload } }, '*');
        } catch (error) {
          status.textContent = 'Invalid JSON';
        }
      });

      confirmButton.addEventListener('click', () => {
        if (!lastPayload) {
          status.textContent = 'No prepared import to apply.';
          return;
        }
        
        const defaultModeSelect = document.getElementById('defaultModeSelect');
        const selectedDefaultMode = defaultModeSelect?.value || null;
        
        status.textContent = 'Applying changes...';
        parent.postMessage({ 
          pluginMessage: { 
            type: 'execute-import', 
            payload: lastPayload,
            defaultMode: selectedDefaultMode
          } 
        }, '*');
        confirmButton.disabled = true;
      });

      structuresFile?.addEventListener('change', (event) => {
        const file = event.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try {
            structuresPayload = JSON.parse(reader.result);
            if (structuresStatus) structuresStatus.textContent = `Loaded ${file.name}`;
          } catch (e) {
            structuresPayload = null;
            if (structuresStatus) structuresStatus.textContent = 'Invalid structures JSON';
          }
        };
        reader.readAsText(file);
      });

      generateStructures?.addEventListener('click', () => {
        if (!structuresPayload) {
          if (structuresStatus) structuresStatus.textContent = 'Load structures JSON first.';
          return;
        }
        structuresStatus.textContent = 'Generating...';
        parent.postMessage({ pluginMessage: { type: 'generate-structures', payload: structuresPayload } }, '*');
      });

      expandVariantsBtn?.addEventListener('click', () => {
        console.log('[Applicator][Expand:ui]', 'click', { selectedAxis, selectedAxisId, selection: latestSelection?.id });
        if (!selectedAxis || !latestSelection?.id) {
          if (applicatorStatus) applicatorStatus.textContent = 'Select an axis and a node first.';
          return;
        }
        const filteredBindings = (latestSelection?.bindings || []).filter(
          (b) => `${b.property}|${b.collectionId}` === selectedAxis.id
        );
        console.log('[Applicator][Expand:ui]', 'bindingsFiltered', filteredBindings.length);
        parent.postMessage(
          {
            pluginMessage: {
              type: 'expand-variants',
              payload: { nodeId: latestSelection.id, axisBindings: filteredBindings }
            }
          },
          '*'
        );
      });

      saveMappingBtn?.addEventListener('click', () => {
        if (!latestSelection?.id) return;
        const mapping = {
          background: roleBackground?.value || '',
          label: roleLabel?.value || '',
          border: roleBorder?.value || '',
          icon: roleIcon?.value || ''
        };
        parent.postMessage({ pluginMessage: { type: 'save-mapping', payload: { nodeId: latestSelection.id, mapping } } }, '*');
      });

      roleBackground?.addEventListener('change', () =>
        updateButtonsState(latestSelection?.status === 'ok', requiredRolesMapped(), hasAxesCached, Boolean(selectedAxis))
      );
      roleLabel?.addEventListener('change', () =>
        updateButtonsState(latestSelection?.status === 'ok', requiredRolesMapped(), hasAxesCached, Boolean(selectedAxis))
      );
      roleBorder?.addEventListener('change', () =>
        updateButtonsState(latestSelection?.status === 'ok', requiredRolesMapped(), hasAxesCached, Boolean(selectedAxis))
      );
      roleIcon?.addEventListener('change', () =>
        updateButtonsState(latestSelection?.status === 'ok', requiredRolesMapped(), hasAxesCached, Boolean(selectedAxis))
      );

      if (applyTokensBtn) {
        applyTokensBtn.disabled = true;
        applyTokensBtn.title = 'Reserved for semantic token application (future)';
      }

      // Export snapshot button
      exportSnapshotBtn?.addEventListener('click', () => {
        exportSnapshotBtn.disabled = true;
        exportSnapshotBtn.textContent = 'Creating snapshot...';
        if (snapshotStatus) snapshotStatus.textContent = 'Exporting...';
        parent.postMessage({ pluginMessage: { type: 'export-snapshot' } }, '*');
      });

      // Copy snapshot button
      copySnapshotBtn?.addEventListener('click', () => {
        snapshotJson.select();
        document.execCommand('copy');
        copySnapshotBtn.textContent = 'Copied!';
        setTimeout(() => {
          copySnapshotBtn.textContent = 'Copy to Clipboard';
        }, 2000);
      });

      // Download snapshot button
      downloadSnapshotBtn?.addEventListener('click', () => {
        const json = snapshotJson.value;
        if (!json) return;
        
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
        a.href = url;
        a.download = `${timestamp}-snapshot.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        downloadSnapshotBtn.textContent = 'Downloaded!';
        setTimeout(() => {
          downloadSnapshotBtn.textContent = 'Download JSON';
        }, 2000);
      });

      // Load snapshot file button
      loadSnapshotButton?.addEventListener('click', () => {
        restoreFileInput.click();
      });

      restoreFileInput?.addEventListener('change', (event) => {
        const file = event.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          restoreSnapshotInput.value = reader.result;
          restoreStatus.textContent = `Loaded ${file.name}`;
          executeRestoreButton.disabled = true;
          lastRestoreSnapshot = null;
          updateRestoreButtonState();
        };
        reader.readAsText(file);
      });

      // Update restore button state
      function updateRestoreButtonState() {
        const hasContent = restoreSnapshotInput.value.trim().length > 0;
        prepareRestoreButton.disabled = !hasContent;
      }

      restoreSnapshotInput?.addEventListener('input', () => {
        executeRestoreButton.disabled = true;
        lastRestoreSnapshot = null;
        updateRestoreButtonState();
      });

      // Initialize restore button state
      updateRestoreButtonState();

      // Migration handlers
      const migrationInput = document.getElementById('migrationInput');
      const migrationFileInput = document.getElementById('migrationFileInput');
      const loadMigrationButton = document.getElementById('loadMigrationButton');
      const prepareMigrationButton = document.getElementById('prepareMigrationButton');
      const executeMigrationButton = document.getElementById('executeMigrationButton');
      const migrationStatus = document.getElementById('migrationStatus');
      const migrationSummary = document.getElementById('migrationSummary');
      let lastMigration = null;

      // Load migration file button
      loadMigrationButton?.addEventListener('click', () => {
        migrationFileInput.click();
      });

      migrationFileInput?.addEventListener('change', (event) => {
        const file = event.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          migrationInput.value = reader.result;
          migrationStatus.textContent = `Loaded ${file.name}`;
          executeMigrationButton.disabled = true;
          lastMigration = null;
          updateMigrationButtonState();
        };
        reader.readAsText(file);
      });

      // Update migration button state
      function updateMigrationButtonState() {
        const hasContent = migrationInput.value.trim().length > 0;
        prepareMigrationButton.disabled = !hasContent;
      }

      migrationInput?.addEventListener('input', () => {
        executeMigrationButton.disabled = true;
        lastMigration = null;
        updateMigrationButtonState();
      });

      // Initialize migration button state
      updateMigrationButtonState();

      // Prepare migration button
      prepareMigrationButton?.addEventListener('click', () => {
        try {
          const migration = JSON.parse(migrationInput.value);
          lastMigration = migration;
          executeMigrationButton.disabled = true;
          migrationStatus.textContent = 'Preparing migration summary...';
          parent.postMessage({ pluginMessage: { type: 'prepare-migration', payload: migration } }, '*');
        } catch (error) {
          migrationStatus.textContent = 'Invalid JSON';
        }
      });

      // Execute migration button
      executeMigrationButton?.addEventListener('click', () => {
        if (!lastMigration) {
          migrationStatus.textContent = 'No prepared migration to apply.';
          return;
        }
        migrationStatus.textContent = 'Applying migration...';
        parent.postMessage({ 
          pluginMessage: { 
            type: 'execute-migration', 
            payload: lastMigration
          } 
        }, '*');
        executeMigrationButton.disabled = true;
      });

      // Prepare restore button
      prepareRestoreButton?.addEventListener('click', () => {
        try {
          const snapshot = JSON.parse(restoreSnapshotInput.value);
          lastRestoreSnapshot = snapshot;
          executeRestoreButton.disabled = true;
          restoreStatus.textContent = 'Preparing restore summary...';
          parent.postMessage({ pluginMessage: { type: 'prepare-restore', payload: snapshot } }, '*');
        } catch (error) {
          restoreStatus.textContent = 'Invalid JSON';
        }
      });

      // Execute restore button
      executeRestoreButton?.addEventListener('click', () => {
        if (!lastRestoreSnapshot) {
          restoreStatus.textContent = 'No prepared restore to apply.';
          return;
        }
        restoreStatus.textContent = 'Restoring from snapshot...';
        parent.postMessage({ 
          pluginMessage: { 
            type: 'execute-restore', 
            payload: lastRestoreSnapshot
          } 
        }, '*');
        executeRestoreButton.disabled = true;
      });

      window.onmessage = (event) => {
        const message = event.data.pluginMessage || {};
        if (message.type === 'import-summary') {
          const payload = message.payload || {};
          confirmButton.disabled = false;
          status.textContent = formatSummary(payload);
        } else if (message.type === 'import-complete') {
          const payload = message.payload || {};
          const debug = payload.debug || {};
          const summaryText = payload.summary ? formatSummary(payload.summary) : 'Import complete';
          status.textContent = `${summaryText} • Color vars: ${
            typeof debug.colorVariablesCount === 'number' ? debug.colorVariablesCount : 0
          }`;
        } else if (message.type === 'import-error') {
          status.textContent = `Error: ${message.payload}`;
        } else if (message.type === 'import-warning') {
          status.textContent = `⚠️ Warning: ${message.payload}`;
        } else if (message.type === 'structures-complete') {
          if (structuresStatus) structuresStatus.textContent = 'Generated eui.button structure.';
        } else if (message.type === 'structures-error') {
          if (structuresStatus) structuresStatus.textContent = `Error: ${message.payload}`;
        } else if (message.type === 'selection-data') {
          latestSelection = message.payload;
          renderSelection(latestSelection);
          const selectionOk = latestSelection?.status === 'ok';
          updateButtonsState(selectionOk, requiredRolesMapped(), hasAxesCached, Boolean(selectedAxis));
        } else if (message.type === 'mapping-saved') {
          if (applicatorStatus) applicatorStatus.textContent = 'Mapping saved.';
        } else if (message.type === 'mapping-error') {
          if (applicatorStatus) applicatorStatus.textContent = `Error: ${message.payload}`;
        } else if (message.type === 'PLUGIN_RELOADED') {
          const ts = message.payload?.timestamp;
          const tsEl = document.getElementById('reloadTimestamp');
          if (ts && tsEl) tsEl.textContent = ts;
        } else if (message.type === 'snapshot-ready') {
          const snapshot = message.payload;
          
          // Показать summary
          if (snapshotCollectionsCount) snapshotCollectionsCount.textContent = snapshot.summary.totalCollections;
          if (snapshotVariablesCount) snapshotVariablesCount.textContent = snapshot.summary.totalVariables;
          if (snapshotUsagesCount) snapshotUsagesCount.textContent = snapshot.summary.totalUsages;
          if (snapshotVariablesWithUsagesCount) snapshotVariablesWithUsagesCount.textContent = snapshot.summary.variablesWithUsages;
          if (snapshotSummary) snapshotSummary.style.display = 'block';
          
          // Показать JSON
          if (snapshotJson) snapshotJson.value = JSON.stringify(snapshot, null, 2);
          if (snapshotResult) snapshotResult.style.display = 'block';
          
          if (exportSnapshotBtn) {
            exportSnapshotBtn.disabled = false;
            exportSnapshotBtn.textContent = 'Create Snapshot';
          }
          if (snapshotStatus) {
            snapshotStatus.textContent = `Snapshot created at ${new Date(snapshot.timestamp).toLocaleString()}`;
          }
        } else if (message.type === 'snapshot-error') {
          if (snapshotStatus) snapshotStatus.textContent = `Error: ${message.payload}`;
          if (exportSnapshotBtn) {
            exportSnapshotBtn.disabled = false;
            exportSnapshotBtn.textContent = 'Create Snapshot';
          }
        } else if (message.type === 'restore-summary') {
          const summary = message.payload;
          executeRestoreButton.disabled = false;
          if (restoreStatus) restoreStatus.textContent = formatRestoreSummary(summary);
        } else if (message.type === 'restore-complete') {
          const result = message.payload;
          const summaryText = result.summary ? formatRestoreSummary(result.summary) : 'Restore complete';
          if (restoreStatus) restoreStatus.textContent = summaryText;
          if (executeRestoreButton) executeRestoreButton.disabled = true;
        } else if (message.type === 'restore-error') {
          if (restoreStatus) restoreStatus.textContent = `Error: ${message.payload}`;
          if (executeRestoreButton) executeRestoreButton.disabled = false;
        } else if (message.type === 'migration-summary') {
          const summary = message.payload;
          executeMigrationButton.disabled = false;
          if (migrationStatus) migrationStatus.textContent = formatMigrationSummary(summary);
          
          // Update summary display
          if (migrationSummary) {
            const totalChanges = document.getElementById('migrationTotalChanges');
            const deletedCount = document.getElementById('migrationDeletedCount');
            const movedCount = document.getElementById('migrationMovedCount');
            const usagesAffected = document.getElementById('migrationUsagesAffected');
            const requiresReview = document.getElementById('migrationRequiresReview');
            
            if (totalChanges) totalChanges.textContent = summary.totalChanges || 0;
            if (deletedCount) deletedCount.textContent = summary.deleted || 0;
            if (movedCount) movedCount.textContent = summary.moved || 0;
            if (usagesAffected) usagesAffected.textContent = summary.totalUsagesAffected || 0;
            if (requiresReview) requiresReview.textContent = summary.requiresReview || 0;
            
            migrationSummary.style.display = 'block';
          }
        } else if (message.type === 'migration-complete') {
          const result = message.payload;
          const summaryText = result.summary ? formatMigrationSummary(result.summary) : 'Migration complete';
          if (migrationStatus) migrationStatus.textContent = summaryText;
          if (executeMigrationButton) executeMigrationButton.disabled = true;
        } else if (message.type === 'migration-error') {
          if (migrationStatus) migrationStatus.textContent = `Error: ${message.payload}`;
          if (executeMigrationButton) executeMigrationButton.disabled = false;
        }
      };

      function formatMigrationSummary(summary) {
        const deleted = summary?.deleted || 0;
        const moved = summary?.moved || 0;
        const totalChanges = summary?.totalChanges || 0;
        const totalUsagesAffected = summary?.totalUsagesAffected || 0;
        const requiresReview = summary?.requiresReview || 0;
        
        let result = `Total changes: ${totalChanges} (Deleted: ${deleted}, Moved: ${moved})`;
        if (totalUsagesAffected > 0) {
          result += ` • Usages affected: ${totalUsagesAffected}`;
        }
        if (requiresReview > 0) {
          result += ` • ⚠️ Requires review: ${requiresReview}`;
        }
        
        return result;
      }

      function formatRestoreSummary(summary) {
        const collections = summary?.collections || {};
        const variables = summary?.variables || {};
        const bindings = summary?.bindings || {};
        const warnings = summary?.warnings || [];
        
        let result = `Collections: +${collections.create || 0} / update ${collections.update || 0} / reuse ${collections.reuse || 0} • `;
        result += `Variables: +${variables.create || 0} / update ${variables.update || 0}`;
        if (variables.delete > 0) {
          result += ` / delete ${variables.delete}`;
        }
        result += ` • Bindings: restore ${bindings.restore || 0}`;
        if (bindings.skipped > 0) {
          result += ` / skipped ${bindings.skipped}`;
        }
        
        if (warnings.length > 0) {
          result += `\n⚠️ Warnings: ${warnings.length}`;
        }
        
        return result;
      }

      refreshSelection?.addEventListener('click', () => {
        if (applicatorStatus) applicatorStatus.textContent = 'Reading selection...';
        parent.postMessage({ pluginMessage: { type: 'request-selection' } }, '*');
      });

      function updateButtonsState(selectionOk, requiredRolesMapped, hasAxes, axisSelected) {
        const saveEnabled = selectionOk && requiredRolesMapped;
        const applyEnabled = false; // not implemented yet
        const expandEnabled = selectionOk && hasAxes && axisSelected;
        if (saveMappingBtn) saveMappingBtn.disabled = !saveEnabled;
        if (applyTokensBtn) applyTokensBtn.disabled = !applyEnabled;
        if (expandVariantsBtn) expandVariantsBtn.disabled = !expandEnabled;
        console.log('[Applicator][UI]', 'buttons', { saveEnabled, applyEnabled, expandEnabled, hasAxes, axisSelected });
      }

      function requiredRolesMapped() {
        return Boolean(roleBackground?.value) && Boolean(roleLabel?.value);
      }

      function renderSelection(selection) {
        if (!selection || selection.status !== 'ok') {
          if (applicatorStatus) applicatorStatus.textContent = selection?.message || 'Select a Frame/Component in Figma to start.';
          selectionDetails.style.display = 'none';
          layersList.style.display = 'none';
          roleMapping.style.display = 'none';
          hasAxesCached = false;
          selectedAxis = null;
          selectedAxisId = null;
          axesBindingsCount = 0;
          if (axesList) axesList.innerHTML = '';
          updateAxisStatus(0, null, 0);
          updateButtonsState(false, false, false, false);
          return;
        }

        if (applicatorStatus) applicatorStatus.textContent = 'Selection ready.';
        selectionDetails.style.display = 'flex';
        layersList.style.display = 'block';
        roleMapping.style.display = 'block';

        selType.textContent = selection.nodeType;
        selName.textContent = selection.name;
        selId.textContent = selection.id || '—';
        selChildCount.textContent = (selection.children || []).length;

        const layers = selection.children || [];
        layersTable.innerHTML = '';
        layers.forEach((layer) => {
          const row = document.createElement('div');
          row.style.display = 'flex';
          row.style.justifyContent = 'space-between';
          row.style.gap = '8px';
          row.style.fontSize = '12px';
          row.style.color = '#cbd5f5';
          row.innerHTML = `<span>${layer.name}</span><span>${layer.type}</span><span>${layer.visible ? 'visible' : 'hidden'}${layer.locked ? ' • locked' : ''}</span>`;
          layersTable.appendChild(row);
        });

        populateRoleSelect(roleBackground, layers, (layer) => layer.type === 'RECTANGLE');
        populateRoleSelect(roleLabel, layers, (layer) => layer.type === 'TEXT');
        populateRoleSelect(roleBorder, layers, (layer) => layer.type === 'RECTANGLE');
        populateRoleSelect(roleIcon, layers, () => true);

        applyMappingToSelects(selection.mapping);
        renderAxes(selection.bindings || []);
        updateButtonsState(true, requiredRolesMapped(), hasAxesCached, Boolean(selectedAxis));
      }

      function populateRoleSelect(selectEl, layers, predicate) {
        if (!selectEl) return;
        selectEl.innerHTML = '';
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = '—';
        selectEl.appendChild(defaultOption);
        layers.forEach((layer) => {
          const opt = document.createElement('option');
          opt.value = layer.id;
          opt.textContent = `${layer.name} (${layer.type})`;
          if (predicate(layer) && !selectEl.value) {
            opt.selected = true;
          }
          selectEl.appendChild(opt);
        });
      }

      function applyMappingToSelects(mapping) {
        if (!mapping) return;
        if (roleBackground) roleBackground.value = mapping.background || '';
        if (roleLabel) roleLabel.value = mapping.label || '';
        if (roleBorder) roleBorder.value = mapping.border || '';
        if (roleIcon) roleIcon.value = mapping.icon || '';
      }

      function renderAxes(bindings) {
        if (!axesList) return;
        axesList.innerHTML = '';
        selectedAxis = null;
        selectedAxisId = null;
        axesBindingsCount = bindings.length || 0;
        hasAxesCached = false;
        updateButtonsState(latestSelection?.status === 'ok', requiredRolesMapped(), hasAxesCached, false);

        if (!bindings.length) {
          const note = document.createElement('div');
          note.style.fontSize = '12px';
          note.style.color = '#cbd5f5';
          note.textContent = 'No variable bindings detected on selection.';
          axesList.appendChild(note);
          updateAxisStatus(0, null, 0);
          return;
        }

        const grouped = {};
        bindings.forEach((b) => {
          const key = `${b.property}|${b.collectionId}`;
          if (!grouped[key])
            grouped[key] = {
              id: key,
              property: b.property,
              collectionName: b.collectionName,
              collectionId: b.collectionId,
              count: 0,
              sample: b,
              bindings: []
            };
          grouped[key].count += 1;
          grouped[key].bindings.push(b);
        });

        Object.values(grouped).forEach((axis) => {
          const row = document.createElement('label');
          row.style.display = 'flex';
          row.style.alignItems = 'center';
          row.style.gap = '8px';
          row.style.fontSize = '12px';
          row.style.color = '#cbd5f5';
          const input = document.createElement('input');
          input.type = 'radio';
          input.name = 'axis';
          input.value = axis.id;
          input.addEventListener('change', () => {
            selectedAxis = axis;
            selectedAxisId = axis.id;
            console.log('[Applicator][Axis]', 'selected', axis.id);
            updateButtonsState(latestSelection?.status === 'ok', requiredRolesMapped(), true, true);
            updateAxisStatus(Object.keys(grouped).length, axis, axis.bindings.length);
          });
          const label = document.createElement('span');
          label.textContent = `${axis.property} • ${axis.collectionName} (${axis.count} bindings)`;
          row.appendChild(input);
          row.appendChild(label);
          axesList.appendChild(row);
        });
        hasAxesCached = Object.keys(grouped).length > 0;
        updateButtonsState(latestSelection?.status === 'ok', requiredRolesMapped(), hasAxesCached, Boolean(selectedAxis));
        updateAxisStatus(Object.keys(grouped).length, selectedAxis, selectedAxis?.bindings?.length ?? 0);
      }

      function updateAxisStatus(axisCount, axis, bindingsUsed) {
        const statusEl = document.getElementById('axesStatusLine');
        if (!statusEl) return;
        const axisLabel = axis ? `${axis.property} • ${axis.collectionName}` : '—';
        statusEl.textContent = `Axes detected: ${axisCount || 0} | Selected axis: ${axisLabel} | Bindings used: ${bindingsUsed || 0}`;
      }

      function formatSummary(summary) {
        const totals = summary?.totals || {};
        const collectionsCreate = totals.collectionsToCreate ?? 0;
        const collectionsReuse = totals.collectionsToReuse ?? 0;
        const variablesCreate = totals.variablesToCreate ?? 0;
        const variablesUpdate = totals.variablesToUpdate ?? 0;
        const modesCount = totals.modesToCreate ?? 0;
        let result = `Collections: +${collectionsCreate} / reuse ${collectionsReuse} • Variables: +${variablesCreate} / update ${variablesUpdate}`;
        if (modesCount > 0) {
          result += ` • Modes: ${modesCount}`;
        }
        return result;
      }
    </script>
  </body>
</html>
