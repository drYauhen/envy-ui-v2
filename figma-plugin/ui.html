<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Envy UI Tokens Adapter</title>
    <style>
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: #0f172a;
        color: #f8fafc;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 16px;
      }

      h1 {
        font-size: 16px;
        margin: 0;
      }

      .tabs {
        display: inline-flex;
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        overflow: hidden;
      }

      .tab {
        background: transparent;
        color: #cbd5f5;
        padding: 10px 14px;
        border: none;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        transition: background 120ms ease, color 120ms ease;
      }

      .tab.active {
        background: rgba(255, 255, 255, 0.1);
        color: #f8fafc;
      }

      .panel {
        display: none;
        flex-direction: column;
        gap: 12px;
      }

      .panel.active {
        display: flex;
      }

      textarea {
        width: 100%;
        min-height: 180px;
        border-radius: 8px;
        border: none;
        padding: 12px;
        font-family: 'JetBrains Mono', Consolas, monospace;
        font-size: 12px;
        resize: vertical;
      }

      button,
      label {
        font-size: 13px;
        font-weight: 600;
        border-radius: 6px;
        cursor: pointer;
      }

      button {
        border: none;
        background: #10b981;
        color: #041421;
        padding: 10px 16px;
        transition: opacity 120ms ease;
      }

      button.secondary {
        background: transparent;
        color: #cbd5f5;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .status {
        font-size: 12px;
        color: #cbd5f5;
        min-height: 18px;
      }

      input[type='file'] {
        display: none;
      }

      .reload-strip {
        font-size: 11px;
        color: #94a3b8;
        padding: 4px 8px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        align-self: flex-start;
      }
    </style>
  </head>
  <body>
    <div class="tabs">
      <button class="tab active" data-tab="variables">Variables</button>
      <button class="tab" data-tab="structures">Structures</button>
      <button class="tab" data-tab="applicator">Applicator</button>
    </div>
    <div id="reloadTimestamp" class="reload-strip"></div>

    <div id="variablesPanel" class="panel active">
      <h1>Import adapter JSON</h1>
      <p style="margin: 0; font-size: 12px; color: #cbd5f5;">
        Paste the contents of <code>build/figma/variables.adapter.json</code> or load it from disk.
      </p>
      <textarea id="adapterInput" placeholder="{\n  \"collections\": []\n}"></textarea>
      <div class="actions">
        <label class="secondary">
          <input type="file" id="fileInput" accept="application/json" />
          Load JSON file
        </label>
        <button id="importButton">Prepare import</button>
        <button id="confirmButton" class="secondary" disabled>Apply changes</button>
        <button id="closeButton" class="secondary">Close</button>
      </div>
      <div class="status" id="status"></div>
    </div>

    <div id="structuresPanel" class="panel">
      <h1>Component / Structure Generator</h1>
      <p style="margin: 0; font-size: 12px; color: #cbd5f5;">Generate ui.button structure from tokens.</p>
      <label class="secondary">
        <input type="file" id="structuresFile" accept="application/json" />
        Load structures JSON
      </label>
      <button id="generateStructures">Generate ui.button</button>
      <div class="status" id="structuresStatus"></div>
    </div>

    <div id="applicatorPanel" class="panel">
      <h1>Applicator</h1>
      <p style="margin: 0; font-size: 12px; color: #cbd5f5;">Map layers to semantic roles. No changes applied.</p>
      <button id="refreshSelection">Refresh selection</button>
      <div class="status" id="applicatorStatus" style="min-height: 18px;"></div>

      <div id="selectionDetails" style="display: none; font-size: 12px; color: #cbd5f5; gap: 4px; flex-direction: column;">
        <div><strong>Selection:</strong> <span id="selType"></span></div>
        <div><strong>Name:</strong> <span id="selName"></span></div>
        <div><strong>ID:</strong> <span id="selId"></span></div>
        <div><strong>Children:</strong> <span id="selChildCount"></span></div>
      </div>

      <div id="layersList" style="display: none;">
        <h2 style="font-size: 13px; margin: 12px 0 4px;">Layers</h2>
        <div id="layersTable" style="display: flex; flex-direction: column; gap: 4px;"></div>
      </div>

      <div id="roleMapping" style="display: none;">
        <h2 style="font-size: 13px; margin: 12px 0 4px;">Semantic roles</h2>
        <div style="display: flex; flex-direction: column; gap: 8px;">
          <label style="display: flex; flex-direction: column; gap: 4px;">
            <span>Background (Rectangle)</span>
            <select id="roleBackground"></select>
          </label>
          <label style="display: flex; flex-direction: column; gap: 4px;">
            <span>Label (Text)</span>
            <select id="roleLabel"></select>
          </label>
          <label style="display: flex; flex-direction: column; gap: 4px;">
            <span>Border (optional)</span>
            <select id="roleBorder"></select>
          </label>
          <label style="display: flex; flex-direction: column; gap: 4px;">
            <span>Icon (optional)</span>
            <select id="roleIcon"></select>
          </label>
        </div>
      </div>

      <div style="margin-top: 12px; display: flex; gap: 8px; flex-wrap: wrap;">
        <button id="saveMapping" disabled>Save Mapping</button>
        <button id="applyTokens" disabled>Apply Tokens</button>
        <button id="expandVariants" disabled>Expand Variants</button>
      </div>
      <p style="margin: 4px 0 0; font-size: 12px; color: #cbd5f5;">
        Coming next: batch-apply variables + expand variants from a seed component.
      </p>
      <h2 style="font-size: 13px; margin: 12px 0 4px;">Detected Variable Axes</h2>
      <div id="axesList" style="display: flex; flex-direction: column; gap: 6px; font-size: 12px; color: #cbd5f5;"></div>
      <div id="axesStatusLine" style="font-size: 11px; color: #94a3b8; min-height: 14px;">Axes detected: 0 | Selected axis: — | Bindings used: 0</div>
    </div>

    <script>
      const tabs = Array.from(document.querySelectorAll('.tab'));
      const variablesPanel = document.getElementById('variablesPanel');
      const structuresPanel = document.getElementById('structuresPanel');
      const applicatorPanel = document.getElementById('applicatorPanel');

      tabs.forEach((tab) => {
        tab.addEventListener('click', () => {
          const target = tab.getAttribute('data-tab');
          tabs.forEach((t) => t.classList.toggle('active', t === tab));
          variablesPanel.classList.toggle('active', target === 'variables');
          structuresPanel.classList.toggle('active', target === 'structures');
          applicatorPanel.classList.toggle('active', target === 'applicator');
        });
      });

      const input = document.getElementById('adapterInput');
      const fileInput = document.getElementById('fileInput');
      const importButton = document.getElementById('importButton');
      const confirmButton = document.getElementById('confirmButton');
      const closeButton = document.getElementById('closeButton');
      const status = document.getElementById('status');
      const structuresStatus = document.getElementById('structuresStatus');
      const generateStructures = document.getElementById('generateStructures');
      const structuresFile = document.getElementById('structuresFile');
      const refreshSelection = document.getElementById('refreshSelection');
      const applicatorStatus = document.getElementById('applicatorStatus');
      const selectionDetails = document.getElementById('selectionDetails');
      const layersList = document.getElementById('layersList');
      const layersTable = document.getElementById('layersTable');
      const roleMapping = document.getElementById('roleMapping');
      const selType = document.getElementById('selType');
      const selName = document.getElementById('selName');
      const selId = document.getElementById('selId');
      const selChildCount = document.getElementById('selChildCount');
      const roleBackground = document.getElementById('roleBackground');
      const roleLabel = document.getElementById('roleLabel');
      const roleBorder = document.getElementById('roleBorder');
      const roleIcon = document.getElementById('roleIcon');
      const axesList = document.getElementById('axesList');
      const expandVariantsBtn = document.getElementById('expandVariants');
      const saveMappingBtn = document.getElementById('saveMapping');
      const applyTokensBtn = document.getElementById('applyTokens');
      let lastPayload = null;
      let structuresPayload = null;
      let latestSelection = null;
      let selectedAxis = null;
      let selectedAxisId = null;
      let hasAxesCached = false;
      let axesBindingsCount = 0;

      // Request timestamp in case the message arrives before UI initialization.
      parent.postMessage({ pluginMessage: { type: 'request-timestamp' } }, '*');

      fileInput.addEventListener('change', (event) => {
        const file = event.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          input.value = reader.result;
          status.textContent = `Loaded ${file.name}`;
          confirmButton.disabled = true;
          lastPayload = null;
        };
        reader.readAsText(file);
      });

      input.addEventListener('input', () => {
        confirmButton.disabled = true;
        lastPayload = null;
      });

      importButton.addEventListener('click', () => {
        try {
          const payload = JSON.parse(input.value);
          lastPayload = payload;
          confirmButton.disabled = true;
          status.textContent = 'Preparing summary...';
          parent.postMessage({ pluginMessage: { type: 'prepare-import', payload } }, '*');
        } catch (error) {
          status.textContent = 'Invalid JSON';
        }
      });

      confirmButton.addEventListener('click', () => {
        if (!lastPayload) {
          status.textContent = 'No prepared import to apply.';
          return;
        }
        status.textContent = 'Applying changes...';
        parent.postMessage({ pluginMessage: { type: 'execute-import', payload: lastPayload } }, '*');
        confirmButton.disabled = true;
      });

      closeButton.addEventListener('click', () => {
        parent.postMessage({ pluginMessage: { type: 'close-plugin' } }, '*');
      });

      structuresFile?.addEventListener('change', (event) => {
        const file = event.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try {
            structuresPayload = JSON.parse(reader.result);
            if (structuresStatus) structuresStatus.textContent = `Loaded ${file.name}`;
          } catch (e) {
            structuresPayload = null;
            if (structuresStatus) structuresStatus.textContent = 'Invalid structures JSON';
          }
        };
        reader.readAsText(file);
      });

      generateStructures?.addEventListener('click', () => {
        if (!structuresPayload) {
          if (structuresStatus) structuresStatus.textContent = 'Load structures JSON first.';
          return;
        }
        structuresStatus.textContent = 'Generating...';
        parent.postMessage({ pluginMessage: { type: 'generate-structures', payload: structuresPayload } }, '*');
      });

      expandVariantsBtn?.addEventListener('click', () => {
        console.log('[Applicator][Expand:ui]', 'click', { selectedAxis, selectedAxisId, selection: latestSelection?.id });
        if (!selectedAxis || !latestSelection?.id) {
          if (applicatorStatus) applicatorStatus.textContent = 'Select an axis and a node first.';
          return;
        }
        const filteredBindings = (latestSelection?.bindings || []).filter(
          (b) => `${b.property}|${b.collectionId}` === selectedAxis.id
        );
        console.log('[Applicator][Expand:ui]', 'bindingsFiltered', filteredBindings.length);
        parent.postMessage(
          {
            pluginMessage: {
              type: 'expand-variants',
              payload: { nodeId: latestSelection.id, axisBindings: filteredBindings }
            }
          },
          '*'
        );
      });

      saveMappingBtn?.addEventListener('click', () => {
        if (!latestSelection?.id) return;
        const mapping = {
          background: roleBackground?.value || '',
          label: roleLabel?.value || '',
          border: roleBorder?.value || '',
          icon: roleIcon?.value || ''
        };
        parent.postMessage({ pluginMessage: { type: 'save-mapping', payload: { nodeId: latestSelection.id, mapping } } }, '*');
      });

      roleBackground?.addEventListener('change', () =>
        updateButtonsState(latestSelection?.status === 'ok', requiredRolesMapped(), hasAxesCached, Boolean(selectedAxis))
      );
      roleLabel?.addEventListener('change', () =>
        updateButtonsState(latestSelection?.status === 'ok', requiredRolesMapped(), hasAxesCached, Boolean(selectedAxis))
      );
      roleBorder?.addEventListener('change', () =>
        updateButtonsState(latestSelection?.status === 'ok', requiredRolesMapped(), hasAxesCached, Boolean(selectedAxis))
      );
      roleIcon?.addEventListener('change', () =>
        updateButtonsState(latestSelection?.status === 'ok', requiredRolesMapped(), hasAxesCached, Boolean(selectedAxis))
      );

      if (applyTokensBtn) {
        applyTokensBtn.disabled = true;
        applyTokensBtn.title = 'Reserved for semantic token application (future)';
      }

      window.onmessage = (event) => {
        const message = event.data.pluginMessage || {};
        if (message.type === 'import-summary') {
          const payload = message.payload || {};
          confirmButton.disabled = false;
          status.textContent = formatSummary(payload);
        } else if (message.type === 'import-complete') {
          const payload = message.payload || {};
          const debug = payload.debug || {};
          const summaryText = payload.summary ? formatSummary(payload.summary) : 'Import complete';
          status.textContent = `${summaryText} • Color vars: ${
            typeof debug.colorVariablesCount === 'number' ? debug.colorVariablesCount : 0
          }`;
        } else if (message.type === 'import-error') {
          status.textContent = `Error: ${message.payload}`;
        } else if (message.type === 'structures-complete') {
          if (structuresStatus) structuresStatus.textContent = 'Generated ui.button structure.';
        } else if (message.type === 'structures-error') {
          if (structuresStatus) structuresStatus.textContent = `Error: ${message.payload}`;
        } else if (message.type === 'selection-data') {
          latestSelection = message.payload;
          renderSelection(latestSelection);
          const selectionOk = latestSelection?.status === 'ok';
          updateButtonsState(selectionOk, requiredRolesMapped(), hasAxesCached, Boolean(selectedAxis));
        } else if (message.type === 'mapping-saved') {
          if (applicatorStatus) applicatorStatus.textContent = 'Mapping saved.';
        } else if (message.type === 'mapping-error') {
          if (applicatorStatus) applicatorStatus.textContent = `Error: ${message.payload}`;
        } else if (message.type === 'PLUGIN_RELOADED') {
          const ts = message.payload?.timestamp;
          const tsEl = document.getElementById('reloadTimestamp');
          if (ts && tsEl) tsEl.textContent = ts;
        }
      };

      refreshSelection?.addEventListener('click', () => {
        if (applicatorStatus) applicatorStatus.textContent = 'Reading selection...';
        parent.postMessage({ pluginMessage: { type: 'request-selection' } }, '*');
      });

      function updateButtonsState(selectionOk, requiredRolesMapped, hasAxes, axisSelected) {
        const saveEnabled = selectionOk && requiredRolesMapped;
        const applyEnabled = false; // not implemented yet
        const expandEnabled = selectionOk && hasAxes && axisSelected;
        if (saveMappingBtn) saveMappingBtn.disabled = !saveEnabled;
        if (applyTokensBtn) applyTokensBtn.disabled = !applyEnabled;
        if (expandVariantsBtn) expandVariantsBtn.disabled = !expandEnabled;
        console.log('[Applicator][UI]', 'buttons', { saveEnabled, applyEnabled, expandEnabled, hasAxes, axisSelected });
      }

      function requiredRolesMapped() {
        return Boolean(roleBackground?.value) && Boolean(roleLabel?.value);
      }

      function renderSelection(selection) {
        if (!selection || selection.status !== 'ok') {
          if (applicatorStatus) applicatorStatus.textContent = selection?.message || 'Select a Frame/Component in Figma to start.';
          selectionDetails.style.display = 'none';
          layersList.style.display = 'none';
          roleMapping.style.display = 'none';
          hasAxesCached = false;
          selectedAxis = null;
          selectedAxisId = null;
          axesBindingsCount = 0;
          if (axesList) axesList.innerHTML = '';
          updateAxisStatus(0, null, 0);
          updateButtonsState(false, false, false, false);
          return;
        }

        if (applicatorStatus) applicatorStatus.textContent = 'Selection ready.';
        selectionDetails.style.display = 'flex';
        layersList.style.display = 'block';
        roleMapping.style.display = 'block';

        selType.textContent = selection.nodeType;
        selName.textContent = selection.name;
        selId.textContent = selection.id || '—';
        selChildCount.textContent = (selection.children || []).length;

        const layers = selection.children || [];
        layersTable.innerHTML = '';
        layers.forEach((layer) => {
          const row = document.createElement('div');
          row.style.display = 'flex';
          row.style.justifyContent = 'space-between';
          row.style.gap = '8px';
          row.style.fontSize = '12px';
          row.style.color = '#cbd5f5';
          row.innerHTML = `<span>${layer.name}</span><span>${layer.type}</span><span>${layer.visible ? 'visible' : 'hidden'}${layer.locked ? ' • locked' : ''}</span>`;
          layersTable.appendChild(row);
        });

        populateRoleSelect(roleBackground, layers, (layer) => layer.type === 'RECTANGLE');
        populateRoleSelect(roleLabel, layers, (layer) => layer.type === 'TEXT');
        populateRoleSelect(roleBorder, layers, (layer) => layer.type === 'RECTANGLE');
        populateRoleSelect(roleIcon, layers, () => true);

        applyMappingToSelects(selection.mapping);
        renderAxes(selection.bindings || []);
        updateButtonsState(true, requiredRolesMapped(), hasAxesCached, Boolean(selectedAxis));
      }

      function populateRoleSelect(selectEl, layers, predicate) {
        if (!selectEl) return;
        selectEl.innerHTML = '';
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = '—';
        selectEl.appendChild(defaultOption);
        layers.forEach((layer) => {
          const opt = document.createElement('option');
          opt.value = layer.id;
          opt.textContent = `${layer.name} (${layer.type})`;
          if (predicate(layer) && !selectEl.value) {
            opt.selected = true;
          }
          selectEl.appendChild(opt);
        });
      }

      function applyMappingToSelects(mapping) {
        if (!mapping) return;
        if (roleBackground) roleBackground.value = mapping.background || '';
        if (roleLabel) roleLabel.value = mapping.label || '';
        if (roleBorder) roleBorder.value = mapping.border || '';
        if (roleIcon) roleIcon.value = mapping.icon || '';
      }

      function renderAxes(bindings) {
        if (!axesList) return;
        axesList.innerHTML = '';
        selectedAxis = null;
        selectedAxisId = null;
        axesBindingsCount = bindings.length || 0;
        hasAxesCached = false;
        updateButtonsState(latestSelection?.status === 'ok', requiredRolesMapped(), hasAxesCached, false);

        if (!bindings.length) {
          const note = document.createElement('div');
          note.style.fontSize = '12px';
          note.style.color = '#cbd5f5';
          note.textContent = 'No variable bindings detected on selection.';
          axesList.appendChild(note);
          updateAxisStatus(0, null, 0);
          return;
        }

        const grouped = {};
        bindings.forEach((b) => {
          const key = `${b.property}|${b.collectionId}`;
          if (!grouped[key])
            grouped[key] = {
              id: key,
              property: b.property,
              collectionName: b.collectionName,
              collectionId: b.collectionId,
              count: 0,
              sample: b,
              bindings: []
            };
          grouped[key].count += 1;
          grouped[key].bindings.push(b);
        });

        Object.values(grouped).forEach((axis) => {
          const row = document.createElement('label');
          row.style.display = 'flex';
          row.style.alignItems = 'center';
          row.style.gap = '8px';
          row.style.fontSize = '12px';
          row.style.color = '#cbd5f5';
          const input = document.createElement('input');
          input.type = 'radio';
          input.name = 'axis';
          input.value = axis.id;
          input.addEventListener('change', () => {
            selectedAxis = axis;
            selectedAxisId = axis.id;
            console.log('[Applicator][Axis]', 'selected', axis.id);
            updateButtonsState(latestSelection?.status === 'ok', requiredRolesMapped(), true, true);
            updateAxisStatus(Object.keys(grouped).length, axis, axis.bindings.length);
          });
          const label = document.createElement('span');
          label.textContent = `${axis.property} • ${axis.collectionName} (${axis.count} bindings)`;
          row.appendChild(input);
          row.appendChild(label);
          axesList.appendChild(row);
        });
        hasAxesCached = Object.keys(grouped).length > 0;
        updateButtonsState(latestSelection?.status === 'ok', requiredRolesMapped(), hasAxesCached, Boolean(selectedAxis));
        updateAxisStatus(Object.keys(grouped).length, selectedAxis, selectedAxis?.bindings?.length ?? 0);
      }

      function updateAxisStatus(axisCount, axis, bindingsUsed) {
        const statusEl = document.getElementById('axesStatusLine');
        if (!statusEl) return;
        const axisLabel = axis ? `${axis.property} • ${axis.collectionName}` : '—';
        statusEl.textContent = `Axes detected: ${axisCount || 0} | Selected axis: ${axisLabel} | Bindings used: ${bindingsUsed || 0}`;
      }

      function formatSummary(summary) {
        const totals = summary?.totals || {};
        const collectionsCreate = totals.collectionsToCreate ?? 0;
        const collectionsReuse = totals.collectionsToReuse ?? 0;
        const variablesCreate = totals.variablesToCreate ?? 0;
        const variablesUpdate = totals.variablesToUpdate ?? 0;
        return `Collections: +${collectionsCreate} / reuse ${collectionsReuse} • Variables: +${variablesCreate} / update ${variablesUpdate}`;
      }
    </script>
  </body>
</html>
