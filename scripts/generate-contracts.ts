// Node.js generator for component contracts (CommonJS, no transpilation required).
// Reads DTCG-compatible tokens and emits literal unions for component axes.

const fs = require('fs');
const path = require('path');

const REPO_ROOT = path.resolve(__dirname, '..');
const CONTRACTS_DIR = path.join(REPO_ROOT, 'contracts');

/**
 * Component â†’ axes configuration.
 * Each axis lists sources (relative JSON files) and a JSON path to read keys from.
 * staticValues can be used for axes that are semantic but not in tokens yet (e.g., slots).
 * This generator is defensive: it reads literal keys only and does not resolve primitives.
 */
const COMPONENTS = {
  button: {
    axes: {
      intent: {
        sources: ['tokens/ui/color/semantic.button.json'],
        path: ['ui', 'button'],
        excludeKeys: ['states']
      },
      size: {
        sources: ['tokens/ui/button/size.json'],
        path: ['ui', 'button', 'size']
      },
      shape: {
        sources: ['tokens/ui/button/shape.json'],
        path: ['ui', 'button', 'shape']
      },
      states: {
        sources: ['tokens/ui/color/semantic.button.json'],
        path: ['ui', 'button', 'states']
      },
      slots: {
        staticValues: ['label', 'startIcon', 'endIcon']
      }
    }
  }
};

const ensureDir = (dir) => {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
};

const readJson = (filePath) => {
  const full = path.isAbsolute(filePath) ? filePath : path.join(REPO_ROOT, filePath);
  const raw = fs.readFileSync(full, 'utf8');
  return JSON.parse(raw);
};

const getObjectAtPath = (obj, jsonPath) => {
  return jsonPath.reduce((acc, key) => (acc && typeof acc === 'object' ? acc[key] : undefined), obj);
};

const collectKeys = (node, excludeKeys = []) => {
  if (!node || typeof node !== 'object' || Array.isArray(node)) return [];
  return Object.keys(node).filter((key) => !excludeKeys.includes(key));
};

const dedupe = (values) => Array.from(new Set(values));

const capitalize = (s) => s.charAt(0).toUpperCase() + s.slice(1);

const generateAxis = (componentName, axis, values) => {
  const base = capitalize(componentName) + capitalize(axis);
  const constName = base;
  const typeName = base;
  const literalList = values.map((v) => `'${v}'`).join(', ');
  return `export const ${constName} = [${literalList}] as const;\nexport type ${typeName} = (typeof ${constName})[number];\n`;
};

const banner = `// AUTO-GENERATED BY scripts/generate-contracts.ts\n// Do not edit manually. Regenerate to pick up token changes.\n// Contract scope: component API literal unions derived from tokens (DTCG-compatible).\n`;

const generateContracts = (componentName, config) => {
  const axisEntries = Object.entries(config.axes).map(([axis, axisConfig]) => {
    const values = [];
    if (axisConfig.staticValues) {
      values.push(...axisConfig.staticValues);
    }
    if (axisConfig.sources && axisConfig.path) {
      axisConfig.sources.forEach((src) => {
        const json = readJson(src);
        const axisNode = getObjectAtPath(json, axisConfig.path);
        values.push(...collectKeys(axisNode, axisConfig.excludeKeys));
      });
    }
    const unique = dedupe(values).sort();
    return generateAxis(componentName, axis, unique);
  });

  const body = axisEntries.join('\n');
  const commentarySources = Object.values(config.axes)
    .flatMap((axis) => axis.sources || [])
    .map((s) => path.relative(REPO_ROOT, path.join(REPO_ROOT, s)));
  const commentary = `/**\n * How this file was produced:\n * - Source tokens: ${commentarySources.join(', ')}\n * - Axes derived by reading keys at configured JSON paths (or staticValues when provided).\n * - No primitives resolved; only literal keys are emitted.\n */\n`;

  return `${banner}${commentary}${body}`;
};

const writeContracts = () => {
  ensureDir(CONTRACTS_DIR);
  Object.entries(COMPONENTS).forEach(([componentName, config]) => {
    const output = generateContracts(componentName, config);
    const fileName = `${componentName}.contract.ts`;
    fs.writeFileSync(path.join(CONTRACTS_DIR, fileName), output, 'utf8');
  });
};

writeContracts();
